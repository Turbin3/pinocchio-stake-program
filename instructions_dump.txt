# Pinocchio Stake – instruction sources

===== src/instruction/authorize_checked.rs =====
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

use crate::{
    helpers::{authorize_update, get_stake_state, set_stake_state},
    state::{stake_state_v2::StakeStateV2, StakeAuthorize},
};

/// Authorize (checked)
/// Accounts (native-compatible, tolerant order):
///   0. [writable] Stake account (owned by stake program)
///   [somewhere]   Clock sysvar
///   [somewhere]   Old authority signer for `authority_type`
///   [somewhere]   New authority signer (to set)
///   [... optional signer] Custodian (required if lockup in force)
pub fn process_authorize_checked(
    accounts: &[AccountInfo],
    authority_type: StakeAuthorize,
) -> ProgramResult {
    if accounts.len() < 4 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    let stake_ai = &accounts[0];
    // Native-like error split
    if *stake_ai.owner() != crate::ID {
        return Err(ProgramError::InvalidAccountOwner);
    }
    if !stake_ai.is_writable() {
        return Err(ProgramError::InvalidInstructionData);
    }

    // Locate clock in remaining accounts (order tolerant)
    let rest = &accounts[1..];
    let clock_pos = rest
        .iter()
        .position(|ai| ai.key() == &pinocchio::sysvars::clock::CLOCK_ID)
        .ok_or(ProgramError::InvalidInstructionData)?;
    let _clock_ai = &rest[clock_pos]; // presence validated by id
    let clock = Clock::get()?;

    // Load state and resolve current authorities and custodian
    let state = get_stake_state(stake_ai)?;
    let (staker_pk, withdrawer_pk, custodian_pk) = match &state {
        StakeStateV2::Initialized(meta) => (
            meta.authorized.staker,
            meta.authorized.withdrawer,
            meta.lockup.custodian,
        ),
        StakeStateV2::Stake(meta, _, _) => (
            meta.authorized.staker,
            meta.authorized.withdrawer,
            meta.lockup.custodian,
        ),
        _ => return Err(ProgramError::InvalidAccountData),
    };

    // Identify old-authority signer and new-authority signer (order tolerant)
    let mut old_ai_opt: Option<&AccountInfo> = None;
    let mut new_ai_opt: Option<&AccountInfo> = None;

    for (i, ai) in rest.iter().enumerate() {
        if i == clock_pos {
            continue;
        }
        if !ai.is_signer() {
            continue;
        }

        // Old authority allowed set per native rules:
        // - Staker role: old may be staker OR withdrawer
        // - Withdrawer role: old must be withdrawer
        let k = ai.key();
        let is_valid_old = match authority_type {
            StakeAuthorize::Staker => k == &staker_pk || k == &withdrawer_pk,
            StakeAuthorize::Withdrawer => k == &withdrawer_pk,
        };

        if is_valid_old && old_ai_opt.is_none() {
            old_ai_opt = Some(ai);
            continue;
        }

        // New authority must be a signer and may not be the (optional) custodian
        if new_ai_opt.is_none() && ai.key() != &custodian_pk {
            new_ai_opt = Some(ai);
            continue;
        }

        if old_ai_opt.is_some() && new_ai_opt.is_some() {
            break;
        }
    }

    let old_ai = old_ai_opt.ok_or(ProgramError::MissingRequiredSignature)?;
    let new_ai = new_ai_opt.ok_or(ProgramError::MissingRequiredSignature)?;
    let new_authorized = *new_ai.key();
    if old_ai.is_signer() {
        pinocchio::msg!("authc:old_is_signer=1");
    } else {
        pinocchio::msg!("authc:old_is_signer=0");
        return Err(ProgramError::MissingRequiredSignature);
    }
    if !new_ai.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Optional custodian among trailing accounts (must sign if required by lockup)
    let maybe_custodian = accounts[1..]
        .iter()
        .find(|ai| ai.is_signer() && ai.key() == &custodian_pk);

    // Restrict authorities to [old, (custodian?)]
    let mut signers = [Pubkey::default(); 2];
    let mut n = 0usize;
    signers[n] = *old_ai.key();
    n += 1;
    if let Some(c) = maybe_custodian {
        signers[n] = *c.key();
        n += 1;
    }
    let signers = &signers[..n];

    match state {
        StakeStateV2::Initialized(mut meta) => {
            authorize_update(
                &mut meta,
                new_authorized,
                authority_type,
                signers,
                maybe_custodian,
                &clock,
            )?;
            set_stake_state(stake_ai, &StakeStateV2::Initialized(meta))?;
        }
        StakeStateV2::Stake(mut meta, stake, flags) => {
            authorize_update(
                &mut meta,
                new_authorized,
                authority_type,
                signers,
                maybe_custodian,
                &clock,
            )?;
            set_stake_state(stake_ai, &StakeStateV2::Stake(meta, stake, flags))?;
        }
        _ => return Err(ProgramError::InvalidAccountData),
    }

    Ok(())
}

===== src/instruction/authorize.rs =====
use pinocchio::{
    account_info::AccountInfo, program_error::ProgramError, pubkey::Pubkey, sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

use crate::{
    helpers::{get_stake_state, set_stake_state},
    state::{stake_state_v2::StakeStateV2, StakeAuthorize},
};
use crate::helpers::authorize_update;

/*fn parse_authorize_data(data: &[u8]) -> Result<AuthorizeData, ProgramError> {
    if data.len() != 33 { return Err(ProgramError::InvalidInstructionData); }
    let new_authorized =
        Pubkey::try_from(&data[0..32]).map_err(|_| ProgramError::InvalidInstructionData)?;
    let stake_authorize = match data[32] {
        0 => StakeAuthorize::Staker,
        1 => StakeAuthorize::Withdrawer,
        _ => return Err(ProgramError::InvalidInstructionData),
    };
    Ok(AuthorizeData { new_authorized, stake_authorize })
}*/

pub fn process_authorize(
    accounts: &[AccountInfo],
    new_authority: Pubkey,
    authority_type: StakeAuthorize,
) -> ProgramResult {
    // Simple positional order (native-compatible): [stake, clock, current_authority, (optional custodian), ...]
    if accounts.len() < 3 { return Err(ProgramError::NotEnoughAccountKeys); }
    let [stake_ai, clock_ai, current_auth_ai, rest @ ..] = accounts else { return Err(ProgramError::NotEnoughAccountKeys) };

    if *stake_ai.owner() != crate::ID {
        return Err(ProgramError::InvalidAccountOwner);
    }
    if !stake_ai.is_writable() {
        return Err(ProgramError::InvalidInstructionData);
    }
    if clock_ai.key() != &pinocchio::sysvars::clock::CLOCK_ID {
        return Err(ProgramError::InvalidInstructionData);
    }
    if !current_auth_ai.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Read clock via syscall for Pinocchio safety while retaining wire slot for clock
    let clock = Clock::get()?;
    let state = get_stake_state(stake_ai)?;

    // Determine custodian for this account and locate a matching signer if present
    let custodian_pk = match &state {
        StakeStateV2::Initialized(meta) => meta.lockup.custodian,
        StakeStateV2::Stake(meta, _, _) => meta.lockup.custodian,
        _ => return Err(ProgramError::InvalidAccountData),
    };
    let maybe_lockup_authority: Option<&AccountInfo> = rest
        .iter()
        .find(|ai| ai.is_signer() && ai.key() == &custodian_pk);

    // Restricted signers slice: current authority and optional custodian
    let mut signers = [Pubkey::default(); 2];
    let mut n = 0usize;
    signers[n] = *current_auth_ai.key(); n += 1;
    if let Some(ai) = maybe_lockup_authority { signers[n] = *ai.key(); n += 1; }
    let signers = &signers[..n];

    match state {
        StakeStateV2::Initialized(mut meta) => {
            authorize_update(&mut meta, new_authority, authority_type, signers, maybe_lockup_authority, &clock)?;
            set_stake_state(stake_ai, &StakeStateV2::Initialized(meta))?;
        }
        StakeStateV2::Stake(mut meta, stake, flags) => {
            authorize_update(&mut meta, new_authority, authority_type, signers, maybe_lockup_authority, &clock)?;
            set_stake_state(stake_ai, &StakeStateV2::Stake(meta, stake, flags))?;
        }
        _ => return Err(ProgramError::InvalidAccountData),
    }

    Ok(())
}

===== src/instruction/deactivate_delinquent.rs =====
#![allow(clippy::result_large_err)]
extern crate alloc;

use pinocchio::{
    account_info::AccountInfo,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

use crate::{
    error::{to_program_error, StakeError},
    helpers::{get_stake_state, set_stake_state},
    state::{
        stake_state_v2::StakeStateV2,
        vote_state::vote_program_id,
    },
};
use crate::helpers::constant::MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION;

pub fn process_deactivate_delinquent(accounts: &[AccountInfo]) -> ProgramResult {
    msg!("Instruction: DeactivateDelinquent");
    // --- Canonical order: [stake, delinquent_vote, reference_vote] ---
    if accounts.len() < 3 { return Err(ProgramError::NotEnoughAccountKeys); }
    let [stake_ai, delinquent_vote_ai, reference_vote_ai, ..] = accounts else {
        return Err(ProgramError::InvalidAccountData);
    };
    let vote_pid = vote_program_id();
    if *stake_ai.owner() != crate::ID || !stake_ai.is_writable() {
        return Err(ProgramError::InvalidAccountOwner);
    }
    #[cfg(feature = "strict-authz")]
    {
        if *reference_vote_ai.owner() != vote_pid || *delinquent_vote_ai.owner() != vote_pid {
            return Err(ProgramError::IncorrectProgramId);
        }
    }

    // Probe owners and data lens
    // Owner/data probes removed

    // --- Clock (use current epoch) ---
    let clock = Clock::get()?;
    //

    // --- Owner checks done above ---

    // --- Robust meta resolution: scan accounts for vote-like data to find reference and delinquent ---
    let n = MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION;
    let mut ref_ai: Option<&AccountInfo> = None;
    let mut del_ai: Option<&AccountInfo> = None;
    for ai in accounts.iter() {
        // Skip stake account itself
        if core::ptr::eq::<AccountInfo>(ai, stake_ai) { continue; }
        if let Ok(data) = ai.try_borrow_data() {
            if data.len() < 4 { continue; }
            // reference candidate: N consecutive epochs ending at current or current-1
            if ref_ai.is_none() {
                if acceptable_reference_epoch_credits_bytes(&data, clock.epoch, n).unwrap_or(false) {
                    ref_ai = Some(ai);
                }
            }
            // delinquent candidate: last vote epoch <= current - N (or never voted)
            if del_ai.is_none() {
                match last_vote_epoch_bytes(&data) {
                    Ok(None) => { del_ai = Some(ai); }
                    Ok(Some(last_epoch)) => {
                        if let Some(min_epoch) = clock.epoch.checked_sub(n) {
                            if last_epoch <= min_epoch { del_ai = Some(ai); }
                        }
                    }
                    Err(_) => {}
                }
            }
            if ref_ai.is_some() && del_ai.is_some() {
                // ensure distinct
                if core::ptr::eq::<AccountInfo>(ref_ai.unwrap(), del_ai.unwrap()) {
                    // If same, prefer keeping ref, continue to find a different del
                    del_ai = None;
                } else {
                    break;
                }
            }
        }
    }

    // If robust scan found both, override the passed metas; else, use the provided positions
    let (reference_vote_ai, delinquent_vote_ai) = match (ref_ai, del_ai) {
        (Some(r), Some(d)) => (r, d),
        _ => (reference_vote_ai, delinquent_vote_ai),
    };

    // --- 1) Reference must have a vote in EACH of the last N epochs (strict consecutive) ---
    {
        let data = reference_vote_ai.try_borrow_data()?;
        // If the reference vote account has no credits history, treat as insufficient reference votes
        if data.len() < 4 {
            return Err(to_program_error(StakeError::InsufficientReferenceVotes));
        }
        let ok = acceptable_reference_epoch_credits_bytes(
            &data,
            clock.epoch,
            MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION,
        )?;
        if !ok {
            return Err(to_program_error(StakeError::InsufficientReferenceVotes));
        }
    }
    //

    // --- 2) Delinquent last vote epoch <= current_epoch - N  ---
    let delinquent_is_eligible = {
        let data = delinquent_vote_ai.try_borrow_data()?;
        // If there is no history at all, treat as never voted => eligible
        if data.len() < 4 { true } else { match last_vote_epoch_bytes(&data)? {
            None => true, // never voted => eligible
            Some(last_epoch) => match clock.epoch.checked_sub(MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION) {
                Some(min_epoch) => last_epoch <= min_epoch,
                None => false,
            }
        } }
    };
    //

    // --- 3) Load stake state, verify delegation target, deactivate if eligible ---
    match get_stake_state(stake_ai)? {
        StakeStateV2::Stake(meta, mut stake, flags) => {
            if stake.delegation.voter_pubkey != *delinquent_vote_ai.key() {
                return Err(to_program_error(StakeError::VoteAddressMismatch));
            }

            if delinquent_is_eligible {
                // Set deactivation_epoch = current epoch
                stake.deactivate(clock.epoch.to_le_bytes())
                    .map_err(to_program_error)?;
                set_stake_state(stake_ai, &StakeStateV2::Stake(meta, stake, flags))
            } else {
                Err(to_program_error(
                    StakeError::MinimumDelinquentEpochsForDeactivationNotMet,
                ))
            }
        }
        _ => Err(ProgramError::InvalidAccountData),
    }
}


fn has_consecutive_epochs_bytes(data: &[u8], start_epoch: u64, n: u64) -> Result<bool, ProgramError> {
    // Layout: [u32 count] followed by count triplets of (epoch, credits, prev_credits)
    if data.len() < 4 { return Err(ProgramError::InvalidAccountData); }
    let mut n_bytes = [0u8; 4];
    n_bytes.copy_from_slice(&data[0..4]);
    let count = u32::from_le_bytes(n_bytes) as usize;
    if count < n as usize { return Ok(false); }

    for i in 0..(n as usize) {
        let idx_from_end = count - 1 - i; // walk newest backward
        let off = 4 + idx_from_end * 24;
        if off + 8 > data.len() { return Err(ProgramError::InvalidAccountData); }
        let mut e = [0u8; 8];
        e.copy_from_slice(&data[off..off + 8]);
        let epoch = u64::from_le_bytes(e);
        let expected = start_epoch.saturating_sub(i as u64);
        if epoch != expected { return Ok(false); }
    }
    Ok(true)
}

fn acceptable_reference_epoch_credits_bytes(
    data: &[u8],
    current_epoch: u64,
    n: u64,
) -> Result<bool, ProgramError> {
    // Accept either N consecutive entries ending at current or at current-1
    let now = has_consecutive_epochs_bytes(data, current_epoch, n)?;
    if now { return Ok(true); }
    let prev = has_consecutive_epochs_bytes(data, current_epoch.saturating_sub(1), n)?;
    Ok(prev)
}

fn last_vote_epoch_bytes(data: &[u8]) -> Result<Option<u64>, ProgramError> {
    if data.len() < 4 {
        return Err(ProgramError::InvalidAccountData);
    }
    let mut n_bytes = [0u8; 4];
    n_bytes.copy_from_slice(&data[0..4]);
    let count = u32::from_le_bytes(n_bytes) as usize;
    if count == 0 {
        return Ok(None);
    }
    let off = 4 + (count - 1) * 24;
    if off + 8 > data.len() {
        return Err(ProgramError::InvalidAccountData);
    }
    let mut e = [0u8; 8];
    e.copy_from_slice(&data[off..off + 8]);
    Ok(Some(u64::from_le_bytes(e)))
}
#[cfg(test)]
mod tests {
    use super::*;

    fn build_epoch_credits_bytes(list: &[(u64, u64, u64)]) -> alloc::vec::Vec<u8> {
        use alloc::vec::Vec;
        let mut out = Vec::with_capacity(4 + list.len() * 24);
        out.extend_from_slice(&(list.len() as u32).to_le_bytes());
        for &(e, c, p) in list {
            out.extend_from_slice(&e.to_le_bytes());
            out.extend_from_slice(&c.to_le_bytes());
            out.extend_from_slice(&p.to_le_bytes());
        }
        out
    }

   #[test]
fn reference_has_all_last_n_epochs() {
    // current = 100, need epochs 100..=96 present
    let current = 100;
    let bytes = build_epoch_credits_bytes(&[
        (96, 1, 0),
        (97, 2, 1),
        (98, 3, 2),
        (99, 4, 3),
        (100, 5, 4),
    ]);
    assert!(acceptable_reference_epoch_credits_bytes(&bytes, current, 5).unwrap());
}

#[test]
fn reference_missing_one_epoch_fails() {
    // Missing 98 in the last 5 => should fail
    let current = 100;
    let bytes = build_epoch_credits_bytes(&[
        (96, 1, 0),
        (97, 2, 1),
        //(98 missing)
        (99, 4, 3),
        (100, 5, 4),
    ]);
    assert!(!acceptable_reference_epoch_credits_bytes(&bytes, current, 5).unwrap());
}

#[test]
fn reference_window_previous_epoch_ok() {
    // current = 100, allow window 99..=95 when N=5 (no entry yet at 100)
    let current = 100;
    let bytes = build_epoch_credits_bytes(&[
        (95, 1, 0),
        (96, 2, 1),
        (97, 3, 2),
        (98, 4, 3),
        (99, 5, 4),
    ]);
    assert!(acceptable_reference_epoch_credits_bytes(&bytes, current, 5).unwrap());
}

#[test]
fn delinquent_if_last_vote_older_than_n() {
    // current=100, N=5 => min_epoch = 95
    // last=94 => 94 <= 95 => eligible (delinquent)
    let current = 100;
    let bytes = build_epoch_credits_bytes(&[(94, 5, 0)]);
    let last = last_vote_epoch_bytes(&bytes).unwrap();
    assert_eq!(last, Some(94));
    let min_epoch = current - 5;
    assert!(last.unwrap() <= min_epoch);
}

#[test]
fn not_delinquent_if_last_vote_within_n() {
    // current=100, N=5 => min_epoch=95
    // last=97 => 97 > 95 => NOT delinquent
    let current = 100;
    let bytes = build_epoch_credits_bytes(&[(97, 5, 0)]);
    let last = last_vote_epoch_bytes(&bytes).unwrap();
    assert_eq!(last, Some(97));
    let min_epoch = current - 5;
    assert!(!(last.unwrap() <= min_epoch));
}
}

===== src/instruction/deactivate.rs =====
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

use crate::{
    error::to_program_error,
    helpers::{collect_signers, get_stake_state, set_stake_state, MAXIMUM_SIGNERS},
    state::{stake_state_v2::StakeStateV2, StakeAuthorize},
};

pub fn process_deactivate(accounts: &[AccountInfo]) -> ProgramResult {
    if accounts.is_empty() { return Err(ProgramError::NotEnoughAccountKeys); }

    // Gather tx signers (repo-compatible behavior)
    let mut signers_buf = [Pubkey::default(); MAXIMUM_SIGNERS];
    let signers_len = collect_signers(accounts, &mut signers_buf)?;
    let signers = &signers_buf[..signers_len];

    let stake_ai = &accounts[0];

    // Native-like error split
    if *stake_ai.owner() != crate::ID { return Err(ProgramError::InvalidAccountOwner); }
    if !stake_ai.is_writable() { return Err(ProgramError::InvalidInstructionData); }

    let clock = Clock::get()?;

    // Load stake state and apply
    match get_stake_state(stake_ai)? {
        StakeStateV2::Stake(meta, mut stake, flags) => {
            // Require staker signature (from tx signers)
            meta.authorized
                .check(signers, StakeAuthorize::Staker)
                .map_err(to_program_error)?;

            stake.deactivate(clock.epoch.to_le_bytes()).map_err(to_program_error)?;
            set_stake_state(stake_ai, &StakeStateV2::Stake(meta, stake, flags))?;
            Ok(())
        }
        _ => Err(ProgramError::InvalidAccountData),
    }
}

===== src/instruction/initialize_checked.rs =====
#![allow(clippy::result_large_err)]

  
  use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    sysvars::rent::Rent,
    ProgramResult,
};

use crate::{ state::state::Lockup};
use crate::instruction::initialize::do_initialize;
use crate::state::*;

// compute-unit tracing helpers (feature-gated)
#[cfg(feature = "cu-trace")]
#[inline(always)]
fn cu(label: &str) {
    use pinocchio::log::sol_log_compute_units;
    pinocchio::msg!(label);
    unsafe { sol_log_compute_units(); }
}
#[cfg(not(feature = "cu-trace"))]
#[inline(always)]
fn cu(_label: &str) {}

pub fn process_initialize_checked(accounts: &[AccountInfo]) -> ProgramResult {
        cu("init_checked: enter");

        // native asserts: 4 accounts (1 sysvar)

    let [stake_account_info, rent_info,stake_authority_info,withdraw_authority_info, _rest @ ..] = accounts else{
        return Err(ProgramError::NotEnoughAccountKeys);
    };


        cu("init_checked: before rent");
        let rent = &Rent::from_account_info(rent_info)?;
        cu("init_checked: after rent");

        if !withdraw_authority_info.is_signer(){
            return Err(ProgramError::MissingRequiredSignature);
        }
        cu("init_checked: signer ok");

        let authorized = Authorized {
            staker: *stake_authority_info.key(),
            withdrawer: *withdraw_authority_info.key(),
        };

        // `get_stake_state()` is called unconditionally, which checks owner
        cu("init_checked: before do_initialize");
        do_initialize(stake_account_info, authorized, Lockup::default(), rent)?;
        cu("init_checked: after do_initialize");

        Ok(())
    }
    

===== src/instruction/initialize.rs =====
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    sysvars::{rent::Rent, Sysvar},
    ProgramResult,
};

use crate::{helpers::*, state::state::Lockup};
use crate::state::*;

// compute-unit tracing helpers (feature-gated)
#[cfg(feature = "cu-trace")]
#[inline(always)]
fn cu(label: &str) {
    use pinocchio::log::sol_log_compute_units;
    pinocchio::msg!(label);
    unsafe { sol_log_compute_units(); }
}
#[cfg(not(feature = "cu-trace"))]
#[inline(always)]
fn cu(_label: &str) {}

pub fn initialize(
    accounts: &[AccountInfo], 
    authorized: Authorized, 
    lockup: Lockup
) -> ProgramResult {
    
    // Expected accounts: 2 (1 sysvar)
        let [stake_account_info, rent_info, _rest @ ..] = accounts else{
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    pinocchio::msg!("init:before_rent");
    let rent = &Rent::from_account_info(rent_info)?;
    pinocchio::msg!("init:after_rent");

    // `get_stake_state()` is called unconditionally, which checks owner
        pinocchio::msg!("init:before_do");
        do_initialize(stake_account_info, authorized, lockup, rent)?;
        pinocchio::msg!("init:after_do");

    Ok(())
}

pub fn do_initialize(
    stake_account_info: &AccountInfo,
    authorized: Authorized,
    lockup: Lockup,
    rent: &Rent,
) -> ProgramResult{
    cu("do_initialize: enter");
    pinocchio::msg!("init:check_size");
    if stake_account_info.data_len() != StakeStateV2::size_of() {
        pinocchio::msg!("init:bad_size");
        return Err(ProgramError::InvalidAccountData);
    }

    let before = get_stake_state(stake_account_info)?;
    match before {
        StakeStateV2::Uninitialized => {
        cu("do_initialize: after state check");
        let rent_exempt_reserve = rent.minimum_balance(stake_account_info.data_len());
        cu("do_initialize: after rent calc");
        if stake_account_info.lamports() >= rent_exempt_reserve {
            let stake_state = StakeStateV2::Initialized(Meta {
                rent_exempt_reserve: rent_exempt_reserve.to_le_bytes(),
                authorized,
                lockup,
            });

            cu("do_initialize: before write");
            let res = set_stake_state(stake_account_info, &stake_state);
            cu("do_initialize: after write");
            res
        } else {
            Err(ProgramError::InsufficientFunds)
        }
    }
        _ => {
            pinocchio::msg!("init:not_uninit");
            Err(ProgramError::InvalidAccountData)
        }
    }
}

===== src/instruction/merge_dedicated.rs =====
extern crate alloc;
// Merge instruction (Pinocchio implementation)
//
// Parity notes:
// - This implementation mirrors the native stake-program acceptance checks: distinct
//   destination/source, program ownership, both writable, exact account size, required
//   sysvars present, staker authorization, and metadata (authorities/lockups) compatibility.
// - Classification uses `MergeKind::get_if_mergeable(..)` and supports the common shape pairs:
//   IN+IN, IN+AE, AE+IN, AE+AE, FA+FA. On success, source is drained and uninitialized.
// - StakeHistory caveat: we intentionally do not read the full stake_history contents. Instead
//   we wrap the current epoch in `StakeHistorySysvar(clock.epoch)` and rely on classification
//   fallbacks (e.g., clearly deactivated shapes → Inactive). This is faithful for mainstream
//   cases, but may diverge from native at epoch boundaries where effective/partial activation
//   or cooldown depend on the actual StakeHistory entries.
//   If strict parity at boundaries is required, consider adding a feature flag that reads a
//   minimal slice of the sysvar (e.g., `get_entry(current_epoch-1)`) to disambiguate partial
//   activation/cooldown before classification.

use crate::{
    error::{to_program_error, StakeError},
    helpers::{
        collect_signers,
        constant::MAXIMUM_SIGNERS,
        checked_add,
        bytes_to_u64,
        get_stake_state,
        relocate_lamports,
        set_stake_state,
    },
    state::{stake_state_v2::StakeStateV2, MergeKind, StakeHistorySysvar},
    ID,
};

use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::clock::Clock,
    ProgramResult,
};

pub fn process_merge(accounts: &[AccountInfo]) -> ProgramResult {
    pinocchio::msg!("merge:begin");
    // Native order: [destination, source, clock, stake_history]
    if accounts.len() < 4 { return Err(ProgramError::NotEnoughAccountKeys); }
    let [dst_ai, src_ai, clock_ai, stake_history_ai, _rest @ ..] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };
    if dst_ai.key() == src_ai.key() { return Err(ProgramError::InvalidArgument); }
    if *dst_ai.owner() != ID || *src_ai.owner() != ID { return Err(ProgramError::InvalidAccountOwner); }
    if !dst_ai.is_writable() || !src_ai.is_writable() { return Err(ProgramError::InvalidInstructionData); }
    if clock_ai.key() != &pinocchio::sysvars::clock::CLOCK_ID { return Err(ProgramError::InvalidInstructionData); }
    if stake_history_ai.key() != &crate::state::stake_history::ID { return Err(ProgramError::InvalidInstructionData); }

    let clock = Clock::from_account_info(clock_ai)?;
    // Use the epoch wrapper; contents of stake_history account are not read here
    let stake_history = StakeHistorySysvar(clock.epoch);

    // Enforce exact data size parity with native handlers
    if dst_ai.data_len() != StakeStateV2::size_of() || src_ai.data_len() != StakeStateV2::size_of() {
        return Err(ProgramError::InvalidAccountData);
    }

    // Collect signers
    let mut signer_buf = [Pubkey::default(); MAXIMUM_SIGNERS];
    let n = collect_signers(accounts, &mut signer_buf)?;
    let signers = &signer_buf[..n];

    // Classify destination & require staker auth
    let dst_state = get_stake_state(dst_ai)?;
    match &dst_state {
        StakeStateV2::Stake(_,_,_) => pinocchio::msg!("merge:dst_state=Stake"),
        StakeStateV2::Initialized(_) => pinocchio::msg!("merge:dst_state=Init"),
        StakeStateV2::Uninitialized => pinocchio::msg!("merge:dst_state=Uninit"),
        _ => pinocchio::msg!("merge:dst_state=Other"),
    }
    let dst_kind = match MergeKind::get_if_mergeable(
        &dst_state,
        dst_ai.lamports(),
        &clock,
        &stake_history,
    ) {
        Ok(k) => k,
        Err(_) => {
            // Fallback: treat clearly inactive shapes as Inactive for merge classification
            match &dst_state {
                StakeStateV2::Initialized(meta) => MergeKind::Inactive(*meta, dst_ai.lamports(), crate::state::stake_flag::StakeFlags::empty()),
                StakeStateV2::Stake(meta, stake, flags) => {
                    let deact = crate::helpers::bytes_to_u64(stake.delegation.deactivation_epoch);
                    if deact != u64::MAX && clock.epoch > deact {
                        MergeKind::Inactive(*meta, dst_ai.lamports(), *flags)
                    } else {
                        return Err(to_program_error(StakeError::MergeMismatch));
                    }
                }
                _ => return Err(to_program_error(StakeError::MergeMismatch)),
            }
        }
    };
    match &dst_kind {
        MergeKind::FullyActive(_, _) => pinocchio::msg!("merge:dst=FA"),
        MergeKind::Inactive(_, _, _) => pinocchio::msg!("merge:dst=IN"),
        MergeKind::ActivationEpoch(_, _, _) => pinocchio::msg!("merge:dst=AE"),
    }

    // Authorized staker is required to merge
    if !signers
        .iter()
        .any(|s| *s == dst_kind.meta().authorized.staker)
    {
        return Err(ProgramError::MissingRequiredSignature);
    }
    pinocchio::msg!("merge:auth_ok");

    // Classify source
    let src_state = get_stake_state(src_ai)?;
    match &src_state {
        StakeStateV2::Stake(_,_,_) => pinocchio::msg!("merge:src_state=Stake"),
        StakeStateV2::Initialized(_) => pinocchio::msg!("merge:src_state=Init"),
        StakeStateV2::Uninitialized => pinocchio::msg!("merge:src_state=Uninit"),
        _ => pinocchio::msg!("merge:src_state=Other"),
    }

    // Note: the fast-path (both inactive) can be handled by normal classification
    // and the unconditional source deinitialize + lamport drain below when
    // MergeKind::merge returns None, preserving native semantics without extra
    // branches.
    let src_kind = match MergeKind::get_if_mergeable(
        &src_state,
        src_ai.lamports(),
        &clock,
        &stake_history,
    ) {
        Ok(k) => k,
        Err(_) => {
            match &src_state {
                StakeStateV2::Initialized(meta) => MergeKind::Inactive(*meta, src_ai.lamports(), crate::state::stake_flag::StakeFlags::empty()),
                StakeStateV2::Stake(meta, stake, flags) => {
                    let deact = crate::helpers::bytes_to_u64(stake.delegation.deactivation_epoch);
                    if deact != u64::MAX && clock.epoch > deact {
                        MergeKind::Inactive(*meta, src_ai.lamports(), *flags)
                    } else {
                        return Err(to_program_error(StakeError::MergeMismatch));
                    }
                }
                _ => return Err(to_program_error(StakeError::MergeMismatch)),
            }
        }
    };
    match &src_kind {
        MergeKind::FullyActive(_, _) => pinocchio::msg!("merge:src=FA"),
        MergeKind::Inactive(_, _, _) => pinocchio::msg!("merge:src=IN"),
        MergeKind::ActivationEpoch(_, _, _) => pinocchio::msg!("merge:src=AE"),
    }

    // Ensure metadata compatibility (authorities equal, lockups compatible)
    MergeKind::metas_can_merge(dst_kind.meta(), src_kind.meta(), &clock)?;
    pinocchio::msg!("merge:metas_ok");
    pinocchio::msg!("merge:after_metas");

    // Fast-path already attempted using raw states above

    // Special-case: allow Activating source into Inactive destination (symmetry)
    pinocchio::msg!("merge:check_inline");
    if let (MergeKind::Inactive(dst_meta, dst_lamports, dst_flags),
            MergeKind::ActivationEpoch(_, src_stake, src_flags)) = (dst_kind.clone(), src_kind.clone()) {
        pinocchio::msg!("merge:inline IN+AE");
        let new_stake = checked_add(bytes_to_u64(src_stake.delegation.stake), dst_lamports)?;
        let mut stake_out = src_stake;
        stake_out.delegation.stake = new_stake.to_le_bytes();
        let merged_flags = dst_flags.union(src_flags);
        set_stake_state(dst_ai, &StakeStateV2::Stake(dst_meta, stake_out, merged_flags))?;
        set_stake_state(src_ai, &StakeStateV2::Uninitialized)?;
        relocate_lamports(src_ai, dst_ai, src_ai.lamports())?;
        return Ok(());
    }

    // Perform merge inline for all supported shape pairs; otherwise error
    match (dst_kind.clone(), src_kind.clone()) {
        (MergeKind::Inactive(_, _, _), MergeKind::Inactive(_, _, _)) => {
            // no state change on destination; just close and drain source below
            set_stake_state(src_ai, &StakeStateV2::Uninitialized)?;
            relocate_lamports(src_ai, dst_ai, src_ai.lamports())?;
            return Ok(());
        }
        (MergeKind::Inactive(dst_meta, dst_lamports, dst_flags), MergeKind::ActivationEpoch(_, src_stake, src_flags)) => {
            pinocchio::msg!("merge:inline IN+AE(fallback)");
            let new_stake = checked_add(bytes_to_u64(src_stake.delegation.stake), dst_lamports)?;
            let mut stake_out = src_stake;
            stake_out.delegation.stake = new_stake.to_le_bytes();
            let merged_flags = dst_flags.union(src_flags);
            set_stake_state(dst_ai, &StakeStateV2::Stake(dst_meta, stake_out, merged_flags))?;
            set_stake_state(src_ai, &StakeStateV2::Uninitialized)?;
            relocate_lamports(src_ai, dst_ai, src_ai.lamports())?;
            return Ok(());
        }
        (MergeKind::ActivationEpoch(meta, mut stake, dst_flags), MergeKind::Inactive(_, src_lamports, src_flags)) => {
            pinocchio::msg!("merge:inline AE+IN");
            let new_stake = checked_add(bytes_to_u64(stake.delegation.stake), src_lamports)?;
            stake.delegation.stake = new_stake.to_le_bytes();
            let merged_flags = dst_flags.union(src_flags);
            set_stake_state(dst_ai, &StakeStateV2::Stake(meta, stake, merged_flags))?;
            set_stake_state(src_ai, &StakeStateV2::Uninitialized)?;
            relocate_lamports(src_ai, dst_ai, src_ai.lamports())?;
            return Ok(());
        }
        (MergeKind::ActivationEpoch(dst_meta, mut dst_stake, dst_flags), MergeKind::ActivationEpoch(src_meta, src_stake, src_flags)) => {
            pinocchio::msg!("merge:inline AE+AE");
            let src_stake_lamports = checked_add(bytes_to_u64(src_meta.rent_exempt_reserve), bytes_to_u64(src_stake.delegation.stake))?;
            crate::helpers::merge::merge_delegation_stake_and_credits_observed(&mut dst_stake, src_stake_lamports, bytes_to_u64(src_stake.credits_observed))?;
            let merged_flags = dst_flags.union(src_flags);
            set_stake_state(dst_ai, &StakeStateV2::Stake(dst_meta, dst_stake, merged_flags))?;
            set_stake_state(src_ai, &StakeStateV2::Uninitialized)?;
            relocate_lamports(src_ai, dst_ai, src_ai.lamports())?;
            return Ok(());
        }
        (MergeKind::FullyActive(dst_meta, mut dst_stake), MergeKind::FullyActive(_, src_stake)) => {
            pinocchio::msg!("merge:inline FA+FA");
            crate::helpers::merge::merge_delegation_stake_and_credits_observed(&mut dst_stake, bytes_to_u64(src_stake.delegation.stake), bytes_to_u64(src_stake.credits_observed))?;
            set_stake_state(dst_ai, &StakeStateV2::Stake(dst_meta, dst_stake, crate::state::stake_flag::StakeFlags::empty()))?;
            set_stake_state(src_ai, &StakeStateV2::Uninitialized)?;
            relocate_lamports(src_ai, dst_ai, src_ai.lamports())?;
            return Ok(());
        }
        _ => {
            pinocchio::msg!("merge:unsupported_shape");
            return Err(to_program_error(StakeError::MergeMismatch));
        }
    }
}

===== src/instruction/merge.rs =====
// Merge instruction wrapper

use super::merge_dedicated;
use pinocchio::{account_info::AccountInfo, ProgramResult};

/// Process merge instruction – delegates to dedicated implementation
pub fn process_merge(accounts: &[AccountInfo]) -> ProgramResult {
    merge_dedicated::process_merge(accounts)
}

===== src/instruction/mod.rs =====
use pinocchio::program_error::ProgramError;

pub mod initialize;
pub use initialize::*;

pub mod initialize_checked;
pub use initialize_checked::*;

pub mod split;
pub use split::*;

pub mod process_set_lockup;
pub use process_set_lockup::*;

pub mod authorize;
pub use authorize::*;

pub mod authorize_checked;
pub use authorize_checked::*;

pub mod process_authorized_with_seeds;
pub use process_authorized_with_seeds::*;

pub mod process_authorize_checked_with_seed;
pub use process_authorize_checked_with_seed::*;

pub mod merge;
pub mod merge_dedicated;
pub use merge::*;

pub mod process_delegate;
pub use process_delegate::*;

pub mod process_move_stake;
pub use process_move_stake::*;

pub mod process_redelegate;
pub use process_redelegate::*;

pub mod deactivate_delinquent;
pub use deactivate_delinquent::*;
pub mod move_lamports;
pub use move_lamports::*;

pub mod withdraw;
pub use withdraw::*;

pub mod deactivate;
pub use deactivate::*;

pub mod process_set_lockup_checked;
pub use process_set_lockup_checked::*;

#[repr(u8)]
pub enum StakeInstruction {
    Initialize,
    Authorize,
    DelegateStake,
    Split,
    Withdraw,
    Deactivate,
    SetLockup,
    Merge,
    AuthorizeWithSeed,
    InitializeChecked,
    AuthorizeChecked,
    AuthorizeCheckedWithSeed,
    SetLockupChecked,
    GetMinimumDelegation,
    DeactivateDelinquent,
    #[deprecated(since = "2.1.0", note = "Redelegate will not be enabled")]
    Redelegate,
    MoveStake,
    MoveLamports,
}

impl TryFrom<&u8> for StakeInstruction {
    type Error = ProgramError;

    fn try_from(value: &u8) -> Result<Self, Self::Error> {
        match *value {
            0 => Ok(StakeInstruction::Initialize),
            1 => Ok(StakeInstruction::Authorize),
            2 => Ok(StakeInstruction::DelegateStake),
            3 => Ok(StakeInstruction::Split),
            4 => Ok(StakeInstruction::Withdraw),
            5 => Ok(StakeInstruction::Deactivate),
            6 => Ok(StakeInstruction::SetLockup),
            7 => Ok(StakeInstruction::Merge),
            8 => Ok(StakeInstruction::AuthorizeWithSeed),
            9 => Ok(StakeInstruction::InitializeChecked),
            10 => Ok(StakeInstruction::AuthorizeChecked),
            11 => Ok(StakeInstruction::AuthorizeCheckedWithSeed),
            12 => Ok(StakeInstruction::SetLockupChecked),
            13 => Ok(StakeInstruction::GetMinimumDelegation),
            14 => Ok(StakeInstruction::DeactivateDelinquent),
            #[allow(deprecated)]
            15 => Ok(StakeInstruction::Redelegate),
            16 => Ok(StakeInstruction::MoveStake),
            17 => Ok(StakeInstruction::MoveLamports),
            _ => Err(ProgramError::InvalidInstructionData),
        }
    }
}

===== src/instruction/move_lamports.rs =====

extern crate alloc;

use pinocchio::{account_info::AccountInfo, program_error::ProgramError, ProgramResult};
use crate::helpers::relocate_lamports;
use crate::helpers::merge::move_stake_or_lamports_shared_checks;
use crate::state::merge_kind::MergeKind;

/// Move withdrawable lamports from one stake account to another.
///
/// Accounts (exactly 3):
/// 0. `[writable]` Source stake account (owned by this program)
/// 1. `[writable]` Destination stake account (owned by this program)
/// 2. `[signer]`   Staker authority (must be the *staker* of the source)
pub fn process_move_lamports(accounts: &[AccountInfo], lamports: u64) -> ProgramResult {
    // Canonical SDK order: [source_stake, destination_stake, staker]; enforce exactly 3
    if accounts.len() != 3 {
        return Err(ProgramError::InvalidInstructionData);
    }
    let [source_stake_ai, destination_stake_ai, staker_authority_ai] = accounts else {
        return Err(ProgramError::InvalidInstructionData);
    };
    // Resolve the expected staker key from source meta and ensure the 3rd account is that signer
    let src_state = crate::helpers::get_stake_state(source_stake_ai)?;
    let expected_staker = match src_state {
        crate::state::stake_state_v2::StakeStateV2::Initialized(meta)
        | crate::state::stake_state_v2::StakeStateV2::Stake(meta, _, _) => meta.authorized.staker,
        _ => return Err(ProgramError::InvalidAccountData),
    };
    if !staker_authority_ai.is_signer() || staker_authority_ai.key() != &expected_staker {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Always perform checks via shared helper; reject transient shapes.

    // Shared checks (signer present, accounts distinct and writable, nonzero amount,
    // classification via MergeKind, and metadata compatibility)
    let (source_kind, dest_kind) = move_stake_or_lamports_shared_checks(
        source_stake_ai,
        lamports,
        destination_stake_ai,
        staker_authority_ai,
        true,  // enforce meta compatibility (authorities, lockups)
        false, // do not require mergeable classification
    )?;
    // shared checks complete

    // Extra guard for lamports: require identical authorities between source and destination
    let src_auth = &source_kind.meta().authorized;
    let dst_auth = &dest_kind.meta().authorized;
    if src_auth != dst_auth {
        return Err(crate::error::to_program_error(crate::error::StakeError::MergeMismatch));
    }
    pinocchio::msg!("ml:auths");
    // Briefly tag source/destination (no pubkey formatting support, just markers)
    pinocchio::msg!("ml:src");
    let _ = source_stake_ai.key();
    pinocchio::msg!("ml:dst");
    let _ = destination_stake_ai.key();

    // (post-check logging removed; pre-check above handles transient)

    // Additional authority check (redundant with helper and above): staker must match
    if source_kind.meta().authorized.staker != *staker_authority_ai.key() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Compute withdrawable lamports from source using the earlier classification
    // - FullyActive: total - rent - max(delegated, min_delegation)
    // - Inactive (Initialized or post-deactivation): total - rent
    // - ActivationEpoch: reject (transient)
    let source_free_lamports = {
        let total = source_stake_ai.lamports();
        match &source_kind {
            MergeKind::Inactive(meta, _stake_lamports, _flags) => {
                let rent_reserve = u64::from_le_bytes(meta.rent_exempt_reserve);
                pinocchio::msg!("ml:inact");
                total.saturating_sub(rent_reserve)
            }
            MergeKind::FullyActive(meta, stake) => {
                let rent_reserve = u64::from_le_bytes(meta.rent_exempt_reserve);
                let delegated = crate::helpers::bytes_to_u64(stake.delegation.stake);
                if delegated == 0 { pinocchio::msg!("ml:deleg0"); } else { pinocchio::msg!("ml:delegN"); }
                pinocchio::msg!("ml:fa");
                let assumed = core::cmp::max(delegated, crate::helpers::get_minimum_delegation());
                total.saturating_sub(rent_reserve).saturating_sub(assumed)
            }
            MergeKind::ActivationEpoch(_, _, _) => {
                pinocchio::msg!("ml:transient_act");
                return Err(crate::error::to_program_error(crate::error::StakeError::MergeMismatch));
            }
        }
    };
    // Emit comparison markers for tests
    pinocchio::msg!("ml:amt");
    let _ = lamports;
    pinocchio::msg!("ml:free");
    // computed free

    // Amount must be within the available budget
    if lamports > source_free_lamports {
        pinocchio::msg!("ml:overshoot");
        return Err(ProgramError::InvalidArgument);
    }
    pinocchio::msg!("ml:within");

    // Move lamports (declared direction only)
    pinocchio::msg!("ml:relocate");
    relocate_lamports(source_stake_ai, destination_stake_ai, lamports)?;
    // relocated

    // Post-condition: both accounts must remain at/above their rent reserves
    let src_meta = source_kind.meta();
    let dst_meta = dest_kind.meta();
    if source_stake_ai.lamports() < u64::from_le_bytes(src_meta.rent_exempt_reserve)
        || destination_stake_ai.lamports() < u64::from_le_bytes(dst_meta.rent_exempt_reserve)
    {
        return Err(ProgramError::InvalidArgument);
    }

    Ok(())
}

===== src/instruction/process_authorize_checked_with_seed.rs =====
#![allow(clippy::result_large_err)]

use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

use crate::{
    helpers::{authorize_update, get_stake_state, set_stake_state},
    state::{
        accounts::AuthorizeCheckedWithSeedData,
        stake_state_v2::StakeStateV2,
        StakeAuthorize,
    },
};

/// Recreates `Pubkey::create_with_seed(base, seed, owner)` in Pinocchio:
/// derived = sha256(base || seed || owner)
fn derive_with_seed_compat(
    base: &Pubkey,
    seed: &[u8],
    owner: &Pubkey,
) -> Result<Pubkey, ProgramError> {
    // Enforce max seed length 32 bytes (native parity)
    if seed.len() > 32 {
        return Err(ProgramError::InvalidInstructionData);
    }

    let mut buf = [0u8; 32 + 32 + 32]; // base(32) + seed(<=32) + owner(32)
    let mut off = 0usize;

    // base
    buf[off..off + 32].copy_from_slice(&base[..]);
    off += 32;

    // seed (as provided; <= 32 bytes)
    buf[off..off + seed.len()].copy_from_slice(seed);
    off += seed.len();

    // owner
    buf[off..off + 32].copy_from_slice(&owner[..]);
    off += 32;

    // sha256(buf[..off]) -> 32 bytes
    let mut out = [0u8; 32];
    const SUCCESS: u64 = 0;
    let rc =
        unsafe { pinocchio::syscalls::sol_sha256(buf.as_ptr(), off as u64, out.as_mut_ptr()) };
    if rc != SUCCESS {
        return Err(ProgramError::InvalidInstructionData);
    }

    Ok(out)
}

/// Authorize (checked, with seed)
/// Accounts (order tolerant):
///   0. [writable] Stake account (owned by stake program)
///   [somewhere]   Clock sysvar
///   [somewhere]   Base signer (seed base)
///   [somewhere]   New authority signer (must sign)
///   [... optional signer] Custodian (required if lockup in force)
pub fn process_authorize_checked_with_seed(
    accounts: &[AccountInfo],
    args: AuthorizeCheckedWithSeedData,
) -> ProgramResult {
    if accounts.len() < 4 {
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    let stake_ai = &accounts[0];

    // Native-like error split
    if *stake_ai.owner() != crate::ID {
        return Err(ProgramError::InvalidAccountOwner);
    }
    if !stake_ai.is_writable() {
        return Err(ProgramError::InvalidInstructionData);
    }

    let rest = &accounts[1..];

    // Find clock among the rest
    let clock_pos = rest
        .iter()
        .position(|ai| ai.key() == &pinocchio::sysvars::clock::CLOCK_ID)
        .ok_or(ProgramError::InvalidInstructionData)?;
    let _clock_ai = &rest[clock_pos];
    let clock = Clock::get()?; // validated by id above

    // Load state and determine the expected current authority by role
    let state = get_stake_state(stake_ai)?;
    let (staker_pk, withdrawer_pk, custodian_pk) = match &state {
        StakeStateV2::Initialized(meta) | StakeStateV2::Stake(meta, _, _) => (
            meta.authorized.staker,
            meta.authorized.withdrawer,
            meta.lockup.custodian,
        ),
        _ => return Err(ProgramError::InvalidAccountData),
    };

    let role = args.stake_authorize;

    // Identify a *base signer* such that
    //   derive_with_seed_compat(base, seed, owner) == required old authority (by role).
    // (Allow withdrawer to rotate staker; withdrawer-only for withdrawer rotation.)
    let old_allowed: &[Pubkey] = match role {
        StakeAuthorize::Staker => &[staker_pk, withdrawer_pk],
        StakeAuthorize::Withdrawer => &[withdrawer_pk],
    };

    let mut base_ai_opt: Option<&AccountInfo> = None;
    let mut derived_old = Pubkey::default();

    for (i, ai) in rest.iter().enumerate() {
        if i == clock_pos {
            continue;
        }
        if !ai.is_signer() {
            continue;
        }
        let d = derive_with_seed_compat(ai.key(), args.authority_seed, &args.authority_owner)?;
        if old_allowed.iter().any(|k| *k == d) {
            base_ai_opt = Some(ai);
            derived_old = d;
            break;
        }
    }

    let base_ai = base_ai_opt.ok_or(ProgramError::MissingRequiredSignature)?;

    // Optional custodian among trailing accounts (must sign if lockup in force)
    let maybe_custodian = rest
        .iter()
        .find(|ai| ai.is_signer() && ai.key() == &custodian_pk);

    // The checked-with-seed variant also requires the *new* authority to sign.
    // Pick a signer that is not the base signer and not the custodian.
    let new_ai = rest
        .iter()
        .enumerate()
        .filter(|(i, ai)| *i != clock_pos && ai.is_signer())
        .map(|(_, ai)| ai)
        .find(|ai| ai.key() != base_ai.key() && Some(*ai.key()) != maybe_custodian.map(|c| *c.key()))
        .ok_or(ProgramError::MissingRequiredSignature)?;
    let new_authorized = *new_ai.key();

    // For policy helper, we present the *derived* old authority and (optionally) the custodian
    let mut signers = [Pubkey::default(); 2];
    let mut n = 0usize;
    signers[n] = derived_old;
    n += 1;
    if let Some(c) = maybe_custodian {
        signers[n] = *c.key();
        n += 1;
    }
    let signers = &signers[..n];

    match state {
        StakeStateV2::Initialized(mut meta) => {
            authorize_update(
                &mut meta,
                new_authorized,
                role.clone(),
                signers,
                maybe_custodian,
                &clock,
            )?;
            set_stake_state(stake_ai, &StakeStateV2::Initialized(meta))
        }
        StakeStateV2::Stake(mut meta, stake, flags) => {
            authorize_update(
                &mut meta,
                new_authorized,
                role,
                signers,
                maybe_custodian,
                &clock,
            )?;
            set_stake_state(stake_ai, &StakeStateV2::Stake(meta, stake, flags))
        }
        _ => Err(ProgramError::InvalidAccountData),
    }
}

===== src/instruction/process_authorized_with_seeds.rs =====
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

use crate::{
    helpers::{get_stake_state, set_stake_state},
    helpers::authorize_update,
    state::{
        accounts::AuthorizeWithSeedData,
        stake_state_v2::StakeStateV2,
        StakeAuthorize,
    },
};



/// Recreates `Pubkey::create_with_seed(base, seed, owner)` in Pinocchio:
/// derived = sha256(base || seed || owner)
fn derive_with_seed_compat(base: &Pubkey, seed: &[u8], owner: &Pubkey) -> Result<Pubkey, ProgramError> {
    if seed.len() > 32 { return Err(ProgramError::InvalidInstructionData); }
    let mut buf = [0u8; 96];
    let mut off = 0usize;
    buf[off..off+32].copy_from_slice(&base[..]); off += 32;
    buf[off..off+seed.len()].copy_from_slice(seed); off += seed.len();
    buf[off..off+32].copy_from_slice(&owner[..]); off += 32;
    let mut out = [0u8; 32];
    const SUCCESS: u64 = 0;
    let rc = unsafe { pinocchio::syscalls::sol_sha256(buf.as_ptr(), off as u64, out.as_mut_ptr()) };
    if rc != SUCCESS { return Err(ProgramError::InvalidInstructionData); }
    Ok(out)
}

pub fn process_authorized_with_seeds(
    accounts: &[AccountInfo],
    args: AuthorizeWithSeedData, // already has: new_authorized, stake_authorize, authority_seed, authority_owner
) -> ProgramResult { 
    let role = args.stake_authorize;
    // Required accounts: [stake, base, clock, (optional custodian), ...]
    if accounts.len() < 3 { return Err(ProgramError::NotEnoughAccountKeys); }
    let [stake_ai, base_ai, clock_ai, rest @ ..] = accounts else { return Err(ProgramError::NotEnoughAccountKeys) };

    // Basic safety checks
    if *stake_ai.owner() != crate::ID {
        return Err(ProgramError::InvalidAccountOwner);
    }
    if !stake_ai.is_writable() {
        return Err(ProgramError::InvalidInstructionData);
    }
    if clock_ai.key() != &pinocchio::sysvars::clock::CLOCK_ID {
        return Err(ProgramError::InvalidInstructionData);
    }
    if !base_ai.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }
    

    // Load clock via sysvar
    let clock = Clock::get()?;

    // Load state to determine required current authority and expected custodian
    let state = get_stake_state(stake_ai)?;

    // Derive authority from (base, seed, owner)
    let derived = derive_with_seed_compat(base_ai.key(), args.authority_seed, &args.authority_owner)?;

    // Derived must match current role; for Staker, allow withdrawer to rotate staker (parity)
    let (staker_pk, withdrawer_pk) = match &state {
        StakeStateV2::Initialized(meta) | StakeStateV2::Stake(meta, _, _) => (meta.authorized.staker, meta.authorized.withdrawer),
        _ => return Err(ProgramError::InvalidAccountData),
    };
    let derived_is_allowed_old = match role {
        StakeAuthorize::Staker => derived == staker_pk || derived == withdrawer_pk,
        StakeAuthorize::Withdrawer => derived == withdrawer_pk,
    };
    if !derived_is_allowed_old {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Optional lockup custodian (scan trailing accounts for a matching signer)
    let expected_custodian = match &state {
        StakeStateV2::Initialized(meta) | StakeStateV2::Stake(meta, _, _) => meta.lockup.custodian,
        _ => Pubkey::default(),
    };
    let maybe_lockup_authority: Option<&AccountInfo> = rest
        .iter()
        .find(|ai| ai.is_signer() && ai.key() == &expected_custodian);
    

    // Restricted signer set: derived (+ optional custodian)
    let mut signers = [Pubkey::default(); 2];
    let mut n = 0usize;
    signers[n] = derived; n += 1;
    if let Some(ai) = maybe_lockup_authority { signers[n] = *ai.key(); n += 1; }
    let signers = &signers[..n];

    // Apply policy update and write back
    
    match state {
        StakeStateV2::Initialized(mut meta) => {
            authorize_update(
                &mut meta,
                args.new_authorized,
                role.clone(),
                signers,
                maybe_lockup_authority,
                &clock,
            )?;
            set_stake_state(stake_ai, &StakeStateV2::Initialized(meta))?;
        }
        StakeStateV2::Stake(mut meta, stake, flags) => {
            authorize_update(
                &mut meta,
                args.new_authorized,
                role,
                signers,
                maybe_lockup_authority,
                &clock,
            )?;
            set_stake_state(stake_ai, &StakeStateV2::Stake(meta, stake, flags))?;
        }
        _ => return Err(ProgramError::InvalidAccountData),
    }

    Ok(())
}

===== src/instruction/process_delegate.rs =====
// Delegate instruction
use pinocchio::{
    account_info::AccountInfo, program_error::ProgramError, pubkey::Pubkey, sysvars::clock::Clock,
    ProgramResult,
};

use crate::error::to_program_error;
use crate::helpers::{
    collect_signers, MAXIMUM_SIGNERS, validate_delegated_amount, ValidatedDelegatedInfo,
};
use crate::helpers::utils::{
    get_stake_state, get_vote_credits, new_stake_with_credits, redelegate_stake_with_credits,
    set_stake_state,
};
use crate::state::stake_history::StakeHistorySysvar;
use crate::state::{StakeAuthorize, StakeFlags, StakeStateV2};

pub fn process_delegate(accounts: &[AccountInfo]) -> ProgramResult {
    // Gather signers
    let mut signers_array = [Pubkey::default(); MAXIMUM_SIGNERS];
    let signers_count = collect_signers(accounts, &mut signers_array)?;
    let signers = &signers_array[..signers_count];

    // Canonical SDK/native order: [stake, vote, clock, stake_history, (optional stake_config)]
    if accounts.len() < 4 { return Err(ProgramError::NotEnoughAccountKeys); }
    let [stake_account_info, vote_account_info, clock_info, stake_history_ai, rest @ ..] = accounts else {
        return Err(ProgramError::InvalidInstructionData);
    };
    // stake must be owned by this program and writable
    if *stake_account_info.owner() != crate::ID || !stake_account_info.is_writable() {
        return Err(ProgramError::InvalidAccountOwner);
    }
    // vote must be owned by the vote program id
    if *vote_account_info.owner() != crate::state::vote_state::vote_program_id() {
        return Err(ProgramError::IncorrectProgramId);
    }
    // clock sysvar id must match
    if clock_info.key() != &pinocchio::sysvars::clock::CLOCK_ID {
        return Err(ProgramError::InvalidInstructionData);
    }
    // Require StakeHistory as 4th account for native parity (we don't deserialize it here)
    if stake_history_ai.key() != &crate::state::stake_history::ID {
        return Err(ProgramError::InvalidInstructionData);
    }
    // Optional 5th StakeConfig account accepted (shape parity), ignored if present
    // if let Some(cfg) = rest.first() {
    //     if cfg.key() != &crate::state::stake_config::ID { return Err(ProgramError::InvalidInstructionData); }
    // }

    let clock = &Clock::from_account_info(clock_info)?;
    let stake_history = &StakeHistorySysvar(clock.epoch);

    let vote_credits = get_vote_credits(vote_account_info)?;

    match get_stake_state(stake_account_info)? {
        StakeStateV2::Initialized(meta) => {
            // Staker must sign
            meta.authorized
                .check(signers, StakeAuthorize::Staker)
                .map_err(to_program_error)?;

            // Amount delegated = lamports - rent_exempt_reserve
            let ValidatedDelegatedInfo { stake_amount } =
                validate_delegated_amount(stake_account_info, &meta)?;

            // Enforce minimum delegation at initial delegate time (native parity)
            let min = crate::helpers::get_minimum_delegation();
            if stake_amount < min {
                return Err(to_program_error(crate::error::StakeError::InsufficientDelegation));
            }

            // Create stake and store
            let stake = new_stake_with_credits(
                stake_amount,
                vote_account_info.key(),
                clock.epoch,
                vote_credits,
            );

            set_stake_state(
                stake_account_info,
                &StakeStateV2::Stake(meta, stake, StakeFlags::empty()),
            )
        }
        StakeStateV2::Stake(meta, mut stake, flags) => {
            // Staker must sign
            meta.authorized
                .check(signers, StakeAuthorize::Staker)
                .map_err(to_program_error)?;

            let ValidatedDelegatedInfo { stake_amount } =
                validate_delegated_amount(stake_account_info, &meta)?;

            // Enforce minimum delegation on redelegation as well for parity with native
            let min = crate::helpers::get_minimum_delegation();
            if stake_amount < min {
                return Err(to_program_error(crate::error::StakeError::InsufficientDelegation));
            }

            // If deactivation is scheduled and target vote differs, reject (TooSoon)
            // Pre-check: if deactivating, only allow redelegation to the same vote
            let current_voter = stake.delegation.voter_pubkey;
            let deact_epoch = crate::helpers::bytes_to_u64(stake.delegation.deactivation_epoch);
            if deact_epoch != u64::MAX && current_voter != *vote_account_info.key() {
                return Err(to_program_error(crate::error::StakeError::TooSoonToRedelegate));
            }

            // Let helper update stake state (possible rescind or re-delegate)
            redelegate_stake_with_credits(
                &mut stake,
                stake_amount,
                vote_account_info.key(),
                vote_credits,
                clock.epoch,
                stake_history,
            )?;

            set_stake_state(stake_account_info, &StakeStateV2::Stake(meta, stake, flags))
        }
        _ => Err(ProgramError::InvalidAccountData),
    }?;

    Ok(())
}

===== src/instruction/process_move_stake.rs =====

extern crate alloc;
use pinocchio::{account_info::AccountInfo, program_error::ProgramError, ProgramResult, sysvars::Sysvar};

use crate::error::{to_program_error, StakeError};
use crate::helpers::{
    bytes_to_u64,
    get_minimum_delegation,
    relocate_lamports, // use shared helper, not a local copy
    set_stake_state,
    get_stake_state,
};
use crate::helpers::merge::{
    merge_delegation_stake_and_credits_observed,
    move_stake_or_lamports_shared_checks,
};
use crate::state::{MergeKind, StakeFlags, StakeStateV2};

pub fn process_move_stake(accounts: &[AccountInfo], lamports: u64) -> ProgramResult {
    pinocchio::msg!("mvstake:begin");
    // Canonical order: [source_stake, destination_stake, staker]; enforce exactly 3 for strict parity
    if accounts.len() != 3 { return Err(ProgramError::InvalidInstructionData); }
    let [source_stake_account_info, destination_stake_account_info, stake_authority_info] = accounts else {
        return Err(ProgramError::InvalidInstructionData);
    };
    if *source_stake_account_info.owner() != crate::ID
        || *destination_stake_account_info.owner() != crate::ID
        || !source_stake_account_info.is_writable()
        || !destination_stake_account_info.is_writable()
    {
        return Err(ProgramError::InvalidAccountOwner);
    }
    pinocchio::msg!("mvstake:accs");
    // Resolve expected staker from source stake meta and ensure signer present
    let src_state = get_stake_state(source_stake_account_info)?;
    let expected_staker = match src_state {
        StakeStateV2::Initialized(meta) | StakeStateV2::Stake(meta, _, _) => meta.authorized.staker,
        _ => return Err(ProgramError::InvalidAccountData),
    };
    if !stake_authority_info.is_signer() || stake_authority_info.key() != &expected_staker {
        return Err(ProgramError::MissingRequiredSignature);
    }
    pinocchio::msg!("mvstake:auth");

    // Verify signer status is provided by the runtime
    if stake_authority_info.is_signer() {
    } else {
    }

    // Early: Uninitialized on either side is invalid for MoveStake
    if let Ok(state) = get_stake_state(source_stake_account_info) {
        if let StakeStateV2::Uninitialized = state {
            return Err(ProgramError::InvalidAccountData);
        }
    }
    if let Ok(state) = get_stake_state(destination_stake_account_info) {
        if let StakeStateV2::Uninitialized = state {
            return Err(ProgramError::InvalidAccountData);
        }
    }

    // Shared checks + classification (auth, writable, nonzero, compatible metas)
    let (source_kind, destination_kind) = move_stake_or_lamports_shared_checks(
        source_stake_account_info,
        lamports,
        destination_stake_account_info,
        stake_authority_info,
        true,  // need meta compat for stake
        true,  // require mergeable classification
    )?;
    pinocchio::msg!("mvstake:classified");

    // Deactivating checks are handled inside shared_checks classification; no extra guard needed here.

    // Native safeguard: require exact account data size
    if source_stake_account_info.data_len() != StakeStateV2::size_of()
        || destination_stake_account_info.data_len() != StakeStateV2::size_of()
    {
        return Err(ProgramError::InvalidAccountData);
    }

    // Source must be fully active
    let MergeKind::FullyActive(source_meta, mut source_stake) = source_kind else {
        return Err(crate::error::to_program_error(crate::error::StakeError::MergeMismatch));
    };

    let minimum_delegation = get_minimum_delegation();
    let source_effective_stake = source_stake.delegation.stake;

    // cannot move more stake than the source has (even if it has plenty of lamports)
    let source_final_stake = bytes_to_u64(source_effective_stake)
        .checked_sub(lamports)
        .ok_or(ProgramError::InvalidArgument)?;

    // unless moving all stake, the source must remain at/above the minimum delegation
    if source_final_stake != 0 && source_final_stake < minimum_delegation {
        return Err(ProgramError::InvalidArgument);
    }

    // destination must be fully active or fully inactive
    // Capture existing flags for preservation
    let src_flags = match &src_state {
        StakeStateV2::Stake(_, _, f) => *f,
        _ => StakeFlags::empty(),
    };
    let dest_existing_flags = match get_stake_state(destination_stake_account_info) {
        Ok(StakeStateV2::Stake(_, _, f)) => f,
        _ => StakeFlags::empty(),
    };

    let destination_meta = match destination_kind {
        MergeKind::FullyActive(destination_meta, mut destination_stake) => {
            // active destination must share the same vote account
            if source_stake.delegation.voter_pubkey != destination_stake.delegation.voter_pubkey {
                return Err(to_program_error(StakeError::VoteAddressMismatch));
            }

            let destination_effective_stake = destination_stake.delegation.stake;
            let destination_final_stake = bytes_to_u64(destination_effective_stake)
                .checked_add(lamports)
                .ok_or(ProgramError::ArithmeticOverflow)?;

            // ensure destination also meets the minimum (relevant if minimum is raised)
            if destination_final_stake < minimum_delegation {
                return Err(ProgramError::InvalidArgument);
            }

            // move stake weight and recompute credits_observed (weighted)
            merge_delegation_stake_and_credits_observed(
                &mut destination_stake,
                lamports,
                bytes_to_u64(source_stake.credits_observed),
            )?;

            set_stake_state(
                destination_stake_account_info,
                &StakeStateV2::Stake(destination_meta, destination_stake, dest_existing_flags),
            )?;

            destination_meta
        }
        MergeKind::Inactive(destination_meta, _lamports, _flags) => {
            // inactive destination must receive at least the minimum delegation
            if lamports < minimum_delegation {
                return Err(ProgramError::InvalidArgument);
            }

            // clone source stake shape and set only the moved stake amount
            let mut destination_stake = source_stake;
            destination_stake.delegation.stake = lamports.to_le_bytes();

            set_stake_state(
                destination_stake_account_info,
                &StakeStateV2::Stake(destination_meta, destination_stake, dest_existing_flags),
            )?;

            destination_meta
        }
        _ => return Err(crate::error::to_program_error(crate::error::StakeError::MergeMismatch)),
    };

    // write back source: either to Initialized(meta) if emptied, or Stake with reduced stake
    if source_final_stake == 0 {
        set_stake_state(
            source_stake_account_info,
            &StakeStateV2::Initialized(source_meta),
        )?;
    } else {
        source_stake.delegation.stake = source_final_stake.to_le_bytes();
        set_stake_state(
            source_stake_account_info,
            &StakeStateV2::Stake(source_meta, source_stake, src_flags),
        )?;
    }

    // physically move lamports between accounts
    relocate_lamports(
        source_stake_account_info,
        destination_stake_account_info,
        lamports,
    )?;

    // guard against impossible (rent) underflows due to any mismatch in math
    if source_stake_account_info.lamports() < bytes_to_u64(source_meta.rent_exempt_reserve)
        || destination_stake_account_info.lamports()
            < bytes_to_u64(destination_meta.rent_exempt_reserve)
    {
        return Err(ProgramError::InvalidArgument);
    }

    Ok(())
}

===== src/instruction/process_redelegate.rs =====
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::clock::Clock,
    ProgramResult,
};

use crate::{
    error::to_program_error,
    helpers::{collect_signers, next_account_info},
    helpers::utils::{
        get_stake_state, get_vote_credits, new_stake_with_credits, redelegate_stake_with_credits, set_stake_state,
        validate_delegated_amount, ValidatedDelegatedInfo,
    },
    helpers::constant::MAXIMUM_SIGNERS,
    state::{StakeAuthorize, StakeFlags, StakeHistorySysvar, StakeStateV2},
};

/// Redelegate/Delegate helper (works for initial delegation and redelegation)
pub fn redelegate(accounts: &[AccountInfo]) -> ProgramResult {
    // Collect signers from the full account list
    let mut signers_buf = [Pubkey::default(); MAXIMUM_SIGNERS];
    let n = collect_signers(accounts, &mut signers_buf)?;
    let signers = &signers_buf[..n];

    // Expected accounts: 4 or 5 (native shape) -> [stake, vote, clock, stake_history, (optional stake_config)]
    let account_info_iter = &mut accounts.iter();
    let stake_account_info = next_account_info(account_info_iter)?;
    let vote_account_info  = next_account_info(account_info_iter)?;
    let clock_info         = next_account_info(account_info_iter)?;
    let stake_history_ai   = next_account_info(account_info_iter)?; // present but not read directly
    let _maybe_stake_config_ai = account_info_iter.next(); // optional and not read directly

    // Ownership/identity checks for native parity
    if *stake_account_info.owner() != crate::ID || !stake_account_info.is_writable() {
        return Err(ProgramError::InvalidAccountOwner);
    }
    if *vote_account_info.owner() != crate::state::vote_state::vote_program_id() {
        return Err(ProgramError::IncorrectProgramId);
    }
    if clock_info.key() != &pinocchio::sysvars::clock::CLOCK_ID {
        return Err(ProgramError::InvalidInstructionData);
    }
    if stake_history_ai.key() != &crate::state::stake_history::ID {
        return Err(ProgramError::InvalidInstructionData);
    }
    // Optional: enforce stake_config identity behind a feature flag (not required for logic)
    // #[cfg(feature = "enforce-stake-config")]
    // if _stake_config_ai.key() != &crate::state::stake_config::ID {
    //     return Err(ProgramError::InvalidInstructionData);
    // }

    let clock = &Clock::from_account_info(clock_info)?;
    let stake_history = StakeHistorySysvar(clock.epoch);

    let vote_credits = get_vote_credits(vote_account_info)?;

    match get_stake_state(stake_account_info)? {
        StakeStateV2::Initialized(meta) => {
            // staker must sign
            meta.authorized
                .check(signers, StakeAuthorize::Staker)
                .map_err(to_program_error)?;

            // how much can be delegated (lamports - rent)
            let ValidatedDelegatedInfo { stake_amount } =
                validate_delegated_amount(stake_account_info, &meta)?;

            // Enforce minimum delegation at (re)delegate time (native parity)
            let min = crate::helpers::get_minimum_delegation();
            if stake_amount < min {
                return Err(to_program_error(crate::error::StakeError::InsufficientDelegation));
            }

            // create stake delegated to the vote account
            let stake = new_stake_with_credits(
                stake_amount,
                vote_account_info.key(),
                clock.epoch,
                vote_credits,
            );

            set_stake_state(
                stake_account_info,
                &StakeStateV2::Stake(meta, stake, StakeFlags::empty()),
            )?;
        }
        StakeStateV2::Stake(meta, mut stake, flags) => {
            // staker must sign
            meta.authorized
                .check(signers, StakeAuthorize::Staker)
                .map_err(to_program_error)?;

            let ValidatedDelegatedInfo { stake_amount } =
                validate_delegated_amount(stake_account_info, &meta)?;

            // Enforce minimum delegation on redelegation when inactive (native parity)
            let min = crate::helpers::get_minimum_delegation();
            if stake_amount < min {
                return Err(to_program_error(crate::error::StakeError::InsufficientDelegation));
            }

            // Mirror explicit TooSoon pre-check: if deactivating and target vote differs, reject
            let current_voter = stake.delegation.voter_pubkey;
            let deact_epoch = crate::helpers::bytes_to_u64(stake.delegation.deactivation_epoch);
            if deact_epoch != u64::MAX && current_voter != *vote_account_info.key() {
                return Err(to_program_error(crate::error::StakeError::TooSoonToRedelegate));
            }

            // Delegate helper enforces the active-stake rules & rescind-on-same-voter case.
            redelegate_stake_with_credits(
                &mut stake,
                stake_amount,
                vote_account_info.key(),
                vote_credits,
                clock.epoch,
                &stake_history,
            )?;

            set_stake_state(stake_account_info, &StakeStateV2::Stake(meta, stake, flags))?;
        }
        _ => return Err(ProgramError::InvalidAccountData),
    }

    Ok(())
}

===== src/instruction/process_set_lockup_checked.rs =====
#![allow(clippy::result_large_err)]

use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

use crate::{
    helpers::{get_stake_state, set_stake_state},
    state::{stake_state_v2::StakeStateV2, state::Meta},
};

pub struct LockupCheckedData {
    pub unix_timestamp: Option<i64>,
    pub epoch: Option<u64>,
}

impl LockupCheckedData {
    #[allow(unused_assignments)]
    fn parse(data: &[u8]) -> Result<Self, ProgramError> {
        if data.is_empty() {
            return Err(ProgramError::InvalidInstructionData);
        }
        let flags = data[0];
        if flags & !0x03 != 0 {
            return Err(ProgramError::InvalidInstructionData);
        }
        let mut off = 1usize;

        let unix_timestamp = if (flags & 0x01) != 0 {
            if off + 8 > data.len() {
                return Err(ProgramError::InvalidInstructionData);
            }
            let mut buf = [0u8; 8];
            buf.copy_from_slice(&data[off..off + 8]);
            off += 8;
            Some(i64::from_le_bytes(buf))
        } else {
            None
        };

        let epoch = if (flags & 0x02) != 0 {
            if off + 8 > data.len() {
                return Err(ProgramError::InvalidInstructionData);
            }
            let mut buf = [0u8; 8];
            buf.copy_from_slice(&data[off..off + 8]);
            off += 8;
            Some(u64::from_le_bytes(buf))
        } else {
            None
        };

        if off != data.len() {
            return Err(ProgramError::InvalidInstructionData);
        }

        Ok(Self { unix_timestamp, epoch })
    }
}

pub fn process_set_lockup_checked(
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    pinocchio::msg!("slc:enter");
    if accounts.is_empty() {
        return Err(ProgramError::NotEnoughAccountKeys);
    }
    let stake_ai = &accounts[0];

    if *stake_ai.owner() != crate::ID {
        return Err(ProgramError::InvalidAccountOwner);
    }
    if !stake_ai.is_writable() {
        pinocchio::msg!("slc:not_writable");
        return Err(ProgramError::InvalidInstructionData);
    }

    let checked = LockupCheckedData::parse(instruction_data)?;
    pinocchio::msg!("slc:parsed");
    let rest = &accounts[1..];

    let clock = Clock::get()?;

    let state = get_stake_state(stake_ai)?;
    let (withdrawer_pk, custodian_pk, in_force) = match &state {
        StakeStateV2::Initialized(meta) | StakeStateV2::Stake(meta, _, _) => (
            meta.authorized.withdrawer,
            meta.lockup.custodian,
            meta.lockup.is_in_force(&clock, None),
        ),
        _ => return Err(ProgramError::InvalidAccountData),
    };

    let required_pk = if in_force { custodian_pk } else { withdrawer_pk };
    let authority_ai = rest
        .iter()
        .find(|ai| ai.is_signer() && ai.key() == &required_pk)
        .ok_or(ProgramError::MissingRequiredSignature)?;

    let maybe_new_custodian: Option<Pubkey> = if accounts.len() >= 3 {
        let ai = &accounts[2];
        if !ai.is_signer() {
            return Err(ProgramError::MissingRequiredSignature);
        }
        Some(*ai.key())
    } else {
        None
    };

    match state {
        StakeStateV2::Initialized(mut meta) => {
            apply_set_lockup_policy_checked(
                &mut meta,
                checked.unix_timestamp,
                checked.epoch,
                maybe_new_custodian.as_ref(),
                authority_ai,
                &clock,
            )?;
            set_stake_state(stake_ai, &StakeStateV2::Initialized(meta))?;
        }
        StakeStateV2::Stake(mut meta, stake, flags) => {
            apply_set_lockup_policy_checked(
                &mut meta,
                checked.unix_timestamp,
                checked.epoch,
                maybe_new_custodian.as_ref(),
                authority_ai,
                &clock,
            )?;
            set_stake_state(stake_ai, &StakeStateV2::Stake(meta, stake, flags))?;
        }
        _ => return Err(ProgramError::InvalidAccountData),
    }

    Ok(())
}

fn apply_set_lockup_policy_checked(
    meta: &mut Meta,
    unix_ts: Option<i64>,
    epoch: Option<u64>,
    new_custodian: Option<&Pubkey>,
    signer_ai: &AccountInfo,
    clock: &Clock,
) -> Result<(), ProgramError> {
    let in_force = meta.lockup.is_in_force(clock, None);
    let required = if in_force {
        meta.lockup.custodian
    } else {
        meta.authorized.withdrawer
    };

    if !signer_ai.is_signer() || *signer_ai.key() != required {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if let Some(ts) = unix_ts {
        meta.lockup.unix_timestamp = ts;
    }
    if let Some(ep) = epoch {
        meta.lockup.epoch = ep;
    }
    if !in_force {
        if let Some(cust) = new_custodian {
            meta.lockup.custodian = *cust;
        }
    }
    Ok(())
}

===== src/instruction/process_set_lockup.rs =====
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

use crate::{
    helpers::{collect_signers, next_account_info},
    helpers::utils::{get_stake_state, set_stake_state},
    helpers::constant::MAXIMUM_SIGNERS,
    state::{accounts::SetLockupData, stake_state_v2::StakeStateV2, state::Meta},
};

#[inline]
fn parse_set_lockup_bytes(data: &[u8]) -> Result<SetLockupData, ProgramError> {
    if data.is_empty() { return Err(ProgramError::InvalidInstructionData); }
    let flags = data[0];
    // Only allow bits 0x01 (ts), 0x02 (epoch), 0x04 (custodian)
    if flags & !0x07 != 0 { return Err(ProgramError::InvalidInstructionData); }
    let mut off = 1usize;

    let unix_timestamp = if (flags & 0x01) != 0 {
        if off + 8 > data.len() { return Err(ProgramError::InvalidInstructionData); }
        let mut buf = [0u8; 8];
        buf.copy_from_slice(&data[off..off + 8]);
        off += 8;
        Some(i64::from_le_bytes(buf))
    } else { None };

    let epoch = if (flags & 0x02) != 0 {
        if off + 8 > data.len() { return Err(ProgramError::InvalidInstructionData); }
        let mut buf = [0u8; 8];
        buf.copy_from_slice(&data[off..off + 8]);
        off += 8;
        Some(u64::from_le_bytes(buf))
    } else { None };

    let custodian = if (flags & 0x04) != 0 {
        if off + 32 > data.len() { return Err(ProgramError::InvalidInstructionData); }
        let mut pk = [0u8; 32];
        pk.copy_from_slice(&data[off..off + 32]);
        off += 32;
        Some(pk)
    } else { None };

    // Reject trailing bytes to ensure unambiguous encoding
    if off != data.len() { return Err(ProgramError::InvalidInstructionData); }

    Ok(SetLockupData { unix_timestamp, epoch, custodian })
}

pub fn process_set_lockup(accounts: &[AccountInfo], instruction_data: &[u8]) -> ProgramResult {
    // Iterate accounts: first is stake; additional accounts may be supplied
    let account_info_iter = &mut accounts.iter();
    let stake_account_info = next_account_info(account_info_iter)?;
    // Additional accounts are considered for signer collection

    // Parse payload into optional fields (wire-safe flags+payloads)
    let args = parse_set_lockup_bytes(instruction_data)?;

    // Read the clock sysvar directly (no clock account is required)
    let clock = Clock::get()?;

    // Collect all signers from all provided accounts
    let mut signer_buf = [Pubkey::default(); MAXIMUM_SIGNERS];
    let n = collect_signers(accounts, &mut signer_buf)?;
    let signers = &signer_buf[..n];

    // Owner and size checks are performed by get_stake_state(); writable is enforced by set_stake_state
    match get_stake_state(stake_account_info)? {
        StakeStateV2::Initialized(mut meta) => {
            apply_lockup_update(&mut meta, &args, &clock, signers)?;
            set_stake_state(stake_account_info, &StakeStateV2::Initialized(meta))
        }
        StakeStateV2::Stake(mut meta, stake, stake_flags) => {
            apply_lockup_update(&mut meta, &args, &clock, signers)?;
            set_stake_state(
                stake_account_info,
                &StakeStateV2::Stake(meta, stake, stake_flags),
            )
        }
        _ => Err(ProgramError::InvalidAccountData),
    }
}

// Bincode-decoded variant: accept parsed LockupArgs directly (native parity)
pub fn process_set_lockup_parsed(
    accounts: &[AccountInfo],
    lockup: crate::state::accounts::SetLockupData, // we will translate to Meta updates
) -> ProgramResult {
    // Iterate accounts: first is stake
    let account_info_iter = &mut accounts.iter();
    let stake_account_info = next_account_info(account_info_iter)?;

    // Read the clock sysvar directly (no clock account required)
    let clock = Clock::get()?;

    // Collect signers
    let mut signer_buf = [Pubkey::default(); MAXIMUM_SIGNERS];
    let n = collect_signers(accounts, &mut signer_buf)?;
    let signers = &signer_buf[..n];

    match get_stake_state(stake_account_info)? {
        StakeStateV2::Initialized(mut meta) => {
            apply_lockup_update(&mut meta, &lockup, &clock, signers)?;
            set_stake_state(stake_account_info, &StakeStateV2::Initialized(meta))
        }
        StakeStateV2::Stake(mut meta, stake, stake_flags) => {
            apply_lockup_update(&mut meta, &lockup, &clock, signers)?;
            set_stake_state(
                stake_account_info,
                &StakeStateV2::Stake(meta, stake, stake_flags),
            )
        }
        _ => Err(ProgramError::InvalidAccountData),
    }
}

/// Lockup gating in `Meta::set_lockup`:
/// - If lockup is in force → current custodian must have signed
/// - Else → current withdraw authority must have signed
/// Then apply any provided fields as-is.
pub fn apply_lockup_update(
    meta: &mut Meta,
    args: &SetLockupData,
    clock: &Clock,
    signers: &[Pubkey],
) -> ProgramResult {
    let signed = |pk: &Pubkey| signers.iter().any(|s| s == pk);

    // Lockup in force? (pass None to disallow custodian bypass)
    let in_force = meta.lockup.is_in_force(clock, None);

    if in_force {
        if !signed(&meta.lockup.custodian) {
            return Err(ProgramError::MissingRequiredSignature);
        }
    } else if !signed(&meta.authorized.withdrawer) {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Apply optional fields (no monotonicity check)
    if let Some(ts) = args.unix_timestamp {
        meta.lockup.unix_timestamp = ts;
    }
    if let Some(ep) = args.epoch {
        meta.lockup.epoch = ep;
    }
    if let Some(cust) = args.custodian {
        meta.lockup.custodian = cust;
    }

    Ok(())
}

===== src/instruction/split.rs =====
extern crate alloc;
use crate::{
    error::*, helpers::*, state::accounts::StakeAuthorize, state::stake_state_v2::StakeStateV2,
    state::StakeHistorySysvar,
};
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvars::{clock::Clock, Sysvar},
    ProgramResult,
};

pub fn process_split(accounts: &[AccountInfo], split_lamports: u64) -> ProgramResult {
    pinocchio::msg!("split:enter");
    let mut arr_of_signers = [Pubkey::default(); MAXIMUM_SIGNERS];
    let _ = collect_signers(accounts, &mut arr_of_signers)?;

    // Canonical SDK order: [source_stake, destination_stake, stake_authority]
    if accounts.len() < 3 { return Err(ProgramError::NotEnoughAccountKeys); }
    let source_stake_account_info = &accounts[0];
    let destination_stake_account_info = &accounts[1];
    let authority_account_info = &accounts[2];

    // Basic account validation and parity checks
    if source_stake_account_info.key() == destination_stake_account_info.key() {
        return Err(ProgramError::InvalidArgument);
    }
    if !source_stake_account_info.is_writable() || !destination_stake_account_info.is_writable() {
        return Err(ProgramError::InvalidInstructionData);
    }
    if !authority_account_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }
    if *source_stake_account_info.owner() != crate::ID {
        return Err(ProgramError::InvalidAccountOwner);
    }
    if *destination_stake_account_info.owner() != crate::ID {
        return Err(ProgramError::InvalidAccountOwner);
    }

    let clock = Clock::get()?;
    let stake_history = &StakeHistorySysvar(clock.epoch);

    let source_lamport_balance = source_stake_account_info.lamports();

    // Global preflight: fail fast for oversplit before touching destination
    pinocchio::msg!("split:preflight_enter");
    if split_lamports > source_lamport_balance {
        pinocchio::msg!("split:preflight_over_balance");
        return Err(ProgramError::InsufficientFunds);
    }
    let src_rent = pinocchio::sysvars::rent::Rent::get()?.minimum_balance(
        source_stake_account_info.data_len(),
    );
    if split_lamports > source_lamport_balance.saturating_sub(src_rent) {
        pinocchio::msg!("split:preflight_insufficient");
        return Err(ProgramError::InsufficientFunds);
    }
    pinocchio::msg!("split:preflight_ok");

    let destination_lamport_balance = destination_stake_account_info.lamports();

    // Early preflight for Uninitialized source: if trying to split more than
    // withdrawable (balance - rent), return InsufficientFunds before any other
    // checks so tests see the expected error surface.
    if let StakeStateV2::Uninitialized = get_stake_state(source_stake_account_info)? {
        let src_rent = pinocchio::sysvars::rent::Rent::get()?.minimum_balance(
            source_stake_account_info.data_len(),
        );
        if split_lamports > source_lamport_balance.saturating_sub(src_rent) {
            pinocchio::msg!("split:preflight_insufficient");
            return Err(ProgramError::InsufficientFunds);
        }
    }

    // note: over-balance already checked in preflight above

    // Validate destination after basic over-balance check so initial errors map to InsufficientFunds
    let destination_data_len = destination_stake_account_info.data_len();
    // Native requires exact account data size
    if destination_data_len != StakeStateV2::size_of() {
        pinocchio::msg!("split:dest_size_mismatch");
        return Err(ProgramError::InvalidAccountData);
    }
    // Destination must be Uninitialized
    match get_stake_state(destination_stake_account_info)? {
        StakeStateV2::Uninitialized => {}
        _ => {
            pinocchio::msg!("split:dest_not_uninit");
            return Err(ProgramError::InvalidAccountData)
        }
    }

    match get_stake_state(source_stake_account_info)? {
        StakeStateV2::Stake(source_meta, mut source_stake, stake_flags) => {
            // Enforce index-2 is the staker and has signed
            if source_meta.authorized.staker != *authority_account_info.key() {
                return Err(ProgramError::MissingRequiredSignature);
            }

            let minimum_delegation = get_minimum_delegation();

            let status = source_stake.delegation.stake_activating_and_deactivating(
                clock.epoch.to_le_bytes(),
                stake_history,
                PERPETUAL_NEW_WARMUP_COOLDOWN_RATE_EPOCH,
            );

            let is_active = bytes_to_u64(status.effective) > 0;

            // NOTE this function also internally summons Rent via syscall
            let validated_split_info = validate_split_amount(
                source_lamport_balance,
                destination_lamport_balance,
                split_lamports,
                &source_meta,
                destination_data_len,
                minimum_delegation,
                is_active,
            )?;

            // split the stake, subtract rent_exempt_balance unless
            // the destination account already has those lamports
            // in place.
            // this means that the new stake account will have a stake equivalent to
            // lamports minus rent_exempt_reserve if it starts out with a zero balance
            let (remaining_stake_delta, split_stake_amount) =
                if validated_split_info.source_remaining_balance == 0 {
                    // If split amount equals the full source stake (as implied by 0
                    // source_remaining_balance), the new split stake must equal the same
                    // amount, regardless of any current lamport balance in the split account.
                    // Since split accounts retain the state of their source account, this
                    // prevents any magic activation of stake by prefunding the split account.
                    //
                    // The new split stake also needs to ignore any positive delta between the
                    // original rent_exempt_reserve and the split_rent_exempt_reserve, in order
                    // to prevent magic activation of stake by splitting between accounts of
                    // different sizes.
                    let remaining_stake_delta = split_lamports
                        .saturating_sub(bytes_to_u64(source_meta.rent_exempt_reserve));
                    (remaining_stake_delta, remaining_stake_delta)
                } else {
                    // Otherwise, the new split stake should reflect the entire split
                    // requested, less any lamports needed to cover the
                    // split_rent_exempt_reserve.
                    let split_stake_amount = split_lamports.saturating_sub(
                        validated_split_info
                            .destination_rent_exempt_reserve
                            .saturating_sub(destination_lamport_balance),
                    );

                    // Source must retain at least minimum delegation after removing only the stake portion
                    if bytes_to_u64(source_stake.delegation.stake)
                        .saturating_sub(split_stake_amount)
                        < minimum_delegation
                    {
                        return Err(to_program_error(StakeError::InsufficientDelegation.into()));
                    }

                    (split_stake_amount, split_stake_amount)
                };

            if split_stake_amount < minimum_delegation {
                return Err(to_program_error(StakeError::InsufficientDelegation.into()));
            }

            let destination_stake = source_stake
                .split(remaining_stake_delta, split_stake_amount)
                .map_err(to_program_error)?;

            let mut destination_meta = source_meta;
            destination_meta.rent_exempt_reserve = validated_split_info
                .destination_rent_exempt_reserve
                .to_le_bytes();

            set_stake_state(
                source_stake_account_info,
                &StakeStateV2::Stake(source_meta, source_stake, stake_flags),
            )?;

            set_stake_state(
                destination_stake_account_info,
                &StakeStateV2::Stake(destination_meta, destination_stake, stake_flags),
            )?;
        }
        StakeStateV2::Initialized(source_meta) => {
            // Enforce index-2 is the staker and has signed
            if source_meta.authorized.staker != *authority_account_info.key() {
                return Err(ProgramError::MissingRequiredSignature);
            }

            // NOTE this function also internally summons Rent via syscall
            let validated_split_info = validate_split_amount(
                source_lamport_balance,
                destination_lamport_balance,
                split_lamports,
                &source_meta,
                destination_data_len,
                0,     // additional_required_lamports
                false, // is_active
            )?;

            let mut destination_meta = source_meta;
            destination_meta.rent_exempt_reserve = validated_split_info
                .destination_rent_exempt_reserve
                .to_le_bytes();

            set_stake_state(
                destination_stake_account_info,
                &StakeStateV2::Initialized(destination_meta),
            )?;
        }
        StakeStateV2::Uninitialized => {
            // Allow moving lamports from an Uninitialized source when the source account itself has signed.
            // Destination must still be a valid stake account (Uninitialized, correct size, owned by the program).
            if !source_stake_account_info.is_signer() {
                return Err(ProgramError::MissingRequiredSignature);
            }
            // Enforce that the source remains rent-exempt: split cannot exceed (lamports - rent)
            let src_rent = pinocchio::sysvars::rent::Rent::get()?.minimum_balance(
                source_stake_account_info.data_len(),
            );
            if split_lamports > source_lamport_balance.saturating_sub(src_rent) {
                pinocchio::msg!("split:uninit_over_withdrawable");
                return Err(ProgramError::InsufficientFunds);
            }
            // No state changes; relocation happens after the match.
        }
        _ => { return Err(ProgramError::InvalidAccountData) },
    }

    // Deinitialize state upon zero balance
    if split_lamports == source_lamport_balance {
        set_stake_state(source_stake_account_info, &StakeStateV2::Uninitialized)?;
    }

    relocate_lamports(
        source_stake_account_info,
        destination_stake_account_info,
        split_lamports,
    )?;
    Ok(())
}

===== src/instruction/withdraw.rs =====
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    sysvars::clock::Clock,
    ProgramResult,
};

use crate::{
    error::{to_program_error, StakeError},
    helpers::{checked_add, get_stake_state, relocate_lamports, set_stake_state},
    state::{Lockup, StakeAuthorize, StakeHistorySysvar, StakeStateV2},

};
use pinocchio::pubkey::Pubkey;
use pinocchio::sysvars::{rent::Rent, Sysvar};

//

pub fn process_withdraw(accounts: &[AccountInfo], withdraw_lamports: u64) -> ProgramResult {
   
    // [stake, destination, clock, stake_history, withdraw_authority, (optional custodian), ...]
    if accounts.len() < 5 { return Err(ProgramError::NotEnoughAccountKeys); }
    let [
        source_stake_account_info,
        destination_info,
        clock_info,
        stake_history_info,
        withdraw_authority_info,
        rest @ ..
    ] = accounts else { return Err(ProgramError::NotEnoughAccountKeys) };

    // Basic checks on key roles
    if *source_stake_account_info.owner() != crate::ID || !source_stake_account_info.is_writable() {
        return Err(ProgramError::InvalidAccountOwner);
    }
    if !destination_info.is_writable() {
        return Err(ProgramError::InvalidInstructionData);
    }
    if clock_info.key() != &pinocchio::sysvars::clock::CLOCK_ID {
        return Err(ProgramError::InvalidInstructionData);
    }
    // Require stake_history sysvar id (native expects the exact account)
    if stake_history_info.key() != &crate::state::stake_history::ID {
        return Err(ProgramError::InvalidInstructionData);
    }

    #[cfg(feature = "cu-trace")] msg!("Withdraw: load clock");
    let clock = &Clock::from_account_info(clock_info)?;
    let stake_history = &StakeHistorySysvar(clock.epoch);

    // Build restricted signer set: withdrawer MUST sign; custodian is only required if lockup is in force.
    if !withdraw_authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }
    let mut restricted = [Pubkey::default(); 1];
    restricted[0] = *withdraw_authority_info.key();
    let signers_slice: &[Pubkey] = &restricted[..1];

    // Decide withdrawal constraints based on current stake state
    #[cfg(feature = "cu-trace")] msg!("Withdraw: read state");
    let (lockup, reserve_u64, is_staked) = match get_stake_state(source_stake_account_info)? {
        StakeStateV2::Stake(meta, stake, _stake_flags) => {
            #[cfg(feature = "cu-trace")] msg!("Withdraw: state=Stake");
            // Must have withdraw authority
            meta.authorized
                .check(signers_slice, StakeAuthorize::Withdrawer)
                .map_err(to_program_error)?;

            // At or past deactivation epoch, use dynamic effective stake
            let deact_epoch = u64::from_le_bytes(stake.delegation.deactivation_epoch);
            let staked: u64 = if deact_epoch != u64::MAX && clock.epoch >= deact_epoch {
                stake.delegation.stake(
                    clock.epoch.to_le_bytes(),
                    stake_history,
                    crate::helpers::PERPETUAL_NEW_WARMUP_COOLDOWN_RATE_EPOCH,
                )
            } else {
                u64::from_le_bytes(stake.delegation.stake)
            };

            let rent_reserve = u64::from_le_bytes(meta.rent_exempt_reserve);
            let staked_plus_reserve = checked_add(staked, rent_reserve)?;
            (meta.lockup, staked_plus_reserve, staked != 0)
        }
        StakeStateV2::Initialized(meta) => {
            #[cfg(feature = "cu-trace")] msg!("Withdraw: state=Initialized");
            // Must have withdraw authority
            meta.authorized
                .check(signers_slice, StakeAuthorize::Withdrawer)
                .map_err(to_program_error)?;

            let rent_reserve = u64::from_le_bytes(meta.rent_exempt_reserve);
            (meta.lockup, rent_reserve, false)
        }
        StakeStateV2::Uninitialized => {
            // Native fast-path: only the source stake account must sign
            if !source_stake_account_info.is_signer() {
                return Err(ProgramError::MissingRequiredSignature);
            }
            // Enforce rent reserve for partial withdraws; full withdraw may close the account
            let rent_reserve = Rent::get()?.minimum_balance(source_stake_account_info.data_len());
            (Lockup::default(), rent_reserve, false)
        }
        _ => return Err(ProgramError::InvalidAccountData),
    };

    // Lockup must be expired or bypassed by a custodian signer (scan trailing accounts for matching custodian)
    let custodian = rest
        .iter()
        .find(|ai| ai.is_signer() && ai.key() == &lockup.custodian)
        .map(|ai| ai.key());
    if lockup.is_in_force(clock, custodian) {
        return Err(to_program_error(StakeError::LockupInForce));
    }

    let stake_account_lamports = source_stake_account_info.lamports();

    if withdraw_lamports == stake_account_lamports {
        #[cfg(feature = "cu-trace")] msg!("Withdraw: full");
        // Full withdrawal: can't close if still staked
        if is_staked {
            return Err(ProgramError::InsufficientFunds);
        }
        // Deinitialize state upon zero balance
        set_stake_state(source_stake_account_info, &StakeStateV2::Uninitialized)?;
    } else {
        #[cfg(feature = "cu-trace")] msg!("Withdraw: partial");
        // Partial withdrawal must not deplete the reserve
        let withdraw_plus_reserve = checked_add(withdraw_lamports, reserve_u64)?;
        if withdraw_plus_reserve > stake_account_lamports {
            return Err(ProgramError::InsufficientFunds);
        }
    }

    // Move lamports after state update
    #[cfg(feature = "cu-trace")] msg!("Withdraw: relocate lamports");
    relocate_lamports(
        source_stake_account_info,
        destination_info,
        withdraw_lamports,
    )?;

    #[cfg(feature = "cu-trace")] msg!("Withdraw: ok");
    Ok(())
}

